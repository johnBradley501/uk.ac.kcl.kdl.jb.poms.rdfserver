<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta charset="utf-8"> 
<title>PoMS RDF: Documentation</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="css/w3.css">
<link rel="stylesheet" href="css/w3-theme-black.css">
<!-- link rel="stylesheet" href="css/css.css">
<link rel="stylesheet" href="css/font-awesome.css" -->
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: sans-serif;}
.w3-sidebar {
  z-index: 3;
  width: 250px;
  top: 43px;
  bottom: 0;
  height: inherit;
}
</style>
<script src="sidebar.js"></script>
</head>
<body>

<!-- Navbar -->
<!-- div class="w3-container w3-top" style="background-color: black; color: white" -->
<div class="w3-top" style="margin: 0px; padding: 0px">
  <div class="w3-theme w3-blue" style="background-color: rgb(232, 224, 218) !important; color: rgb(40, 40, 255) !important;">
     <div class="w3-theme w3-teal" style="background: black url('images/header-banner.jpg') top left no-repeat; 	height: 140px;">
      <h3 style="height: 175px; margin-top: 0px;margin-left: 130px; line-height: 155px">PoMS: RDF Services Documentation</h3>
    </div>
  </div>
  <div class="w3-bar w3-left-align w3-large" style="background-color: black; color: white">
    <a class="w3-bar-item w3-button w3-right w3-hide-large w3-hover-white w3-large w3-theme-l1" href="javascript:void(0)" onclick="w3_open()"><i class="fa fa-bars"></i></a>
    <a href="index.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Home</a>
    <a href="why.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Why RDF</a>
    <a href="using.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Using the Server</a>
    <a href="ontology.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">PoMS Ontology</a>
    <a href="#" class="w3-bar-item w3-button w3-theme-l1e">SPARQL Examples</a>
    <a href="http://www.poms.ac.uk" class="w3-bar-item w3-button w3-hide-small w3-hide-medium w3-hover-white w3-right">PoMS Home</a>
    <a href="/rdf" class="w3-bar-item w3-button w3-hide-small w3-hide-medium w3-hover-white w3-right">PoMS RDF Server</a>
   </div>
</div>

<!-- Sidebar -->
<nav class="w3-sidebar w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left" id="mySidebar" style="top: 183px">
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-right w3-xlarge w3-padding-large w3-hover-black w3-hide-large" title="Close Menu">
    <i class="fa fa-remove"></i>
  </a>
  <h4 class="w3-bar-item"><b>Contents</b></h4>
  <div id="sidebar-contents">
  </div>
</nav>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- Main content: shift it to the right by 250 pixels when the sidebar is visible -->
<div style="height: 170px;">&nbsp;</div>
<div class="w3-main" style="margin-left:250px">

  <div class="w3-row">
    <div class="w3-twothird w3-container">
      <h1 class="w3-text-blue" id="top">SPARQL examples</h1>
	<p>Although one can use the facilities of the rdf4j workbench components provided by PoMS's RDF server to look at RDF data, and useful work can be done in this way alone, far more can be done through SPARQL queries. However, PoMS's data, like most substantive RDF data is complex, and it takes a while to sort out how to create useful queries. This document provides some examples of simple and more complex queries to help you get started with the task of creating your own.</p>
	<p>Unfortunately it would be far too ambitious to create a tutorial which introduces the fundamentals for the SPARQL query
	language to those who are entirely unfamiliar with it.  Instead, it is assumed here that the reader already has the ability to create SPARQL queries.  Those who are not familiar with SPARQL might first wish to explore one or more of the following introductory tutorials before continuing with this document.</p>
	<ul>
	<li>LinkDataTools.com's <a href="http://www.linkeddatatools.com/querying-semantic-data" target="_blank">Tutorial 5: Querying Semantic Data</a></li>
	<li>Jena's <a href="https://jena.apache.org/tutorials/sparql_query1.html" target="_blank">SPARQL Tutorial - A First SPARQL Query</a></li>
	<li>Dataversity's <a href="https://www.dataversity.net/introduction-to-sparql/#" target="_blank">Introduction to: SPARQL</a></li>
	</ul>
	<p>Even after one understands how SPARQL queries are constructed, if one intends to apply this to the PoMS material it is still necessary to become familiar with PoMS data's structure, since one will need to exploit the structure in order
	to write useful queries against PoMS.  There are two areas where one can read about PoMS's RDF structure:</p>
	<ol>
	<li>These documentation pages have a page dedicated to PoMS's data ontology.  The POMS Ontology tab, above will take you to it.
	Of particular use there is the <i>Ontology Relationship Diagram</i>, which you can open
	<a href="images/ontology-diagram.png" target="_blank">here</a>.</li>
	<li>There is also a set of HTML pages created by the OWLDoc application that present the PoMS ontology in detail, including materials about all the data properties
	which are not fully described elsewhere.  You can open it <a href="/rdf/ontology/doc/" target="_blank">here</a>.</li>
	</ol>
<p>Finally, before we begin looking at the SPARQL code a brief explanation about how to interact with materials in the present page you are currently looking at might be in order.</p>
	<ol>
	  <li>Many of the links to URIs in this text will invoke the RDF server, and the HTML link is set up here so that results will open in a new browser window. Thus, to return to this text after you have examined what the link has generated, you will be able to simply close this new window containing the results and resume reading here.</li>
	  <li>Furthermore, this document's SPARQL queries have been placed inside a small HTML form. Thus, the code can readily be sent to the server to be carried out simply by pushing the form's <i>Execute</i> button.  Here too the results will open in a new browser window, which can be closed once you have examined the results.  Alternatively (and you should try this at least once), one could copy the SPARQL query code to the server's own SPARQL query form, and run it there instead.</li>
	</ol>
	<h3 id="first">A first query: authority list values</h3>
	  <p>Often while constructing SPARQL queries one finds that one needs to constrain a selection of data to material that is connected to an item in one of PoMS's authority lists. For example, in this sequence of queries we will be looking at charters where women are grantors. To constrain their role in the charter's transaction factoid to Grantor we need to specify this through the URI for the role (<code>vocab:Role</code>) of <i>Grantor</i>. The question then arises, which particular URI is this?</p>
<p>One can, of course, enter the server's <i>Classes</i> display (via the server's left-side menu) and request information in the dataset related to <code>vocab:Role</code>. Click <a href="/rdf/repositories/poms/explore?resource=vocab%3ARole" target="_blank">here</a> to see the result. After all the information related to how <code>vocab:Role</code> is defined in the PoMS ontology, one will find a list of statements that assert that certain URIs are defined as Roles. One of these, picked here at random, is <a href="/rdf/entity/Role/16" target="_blank">&lt;http://www.poms.ac.uk/rdf/entity/Role/16&gt;</a>, and if you look at the statements associated with this role you can see one that one of them (<code>vocab:hasName</code>) provides a name for it of "Addressee" -- thus asserting that this particular URI represents a role of <i>Addressee</i>.</p>
<p>How do you find out which one represents the grantor role? One <i>could</i> open each instance of a <code>vocab:Role</code> URI to find the one for Grantor but the URI itself unfortunately gives little clue about which one it will be. Instead, it is better to build a simmple SPARQL query that finds all things that are asserted to be of class <code>vocab:Role</code>, locates for each of these the triple that has a predicate of <code>vocab:hasName</code> and displays the URI for each one, with the name associated with it.</p>
<p>Here is the SPARQL query that does this, placed in an HTML form from which you can execute it:</p>
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="8" cols="80" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
select ?name ?roleURI
where {
 ?roleURI a vocab:Role;
    vocab:hasName ?name.
} order by ?name</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>

<p>From the resulting display we can see that &lt;http://www.poms.ac.uk/rdf/entity/Role/5&gt; is the <i>Grantor</i> role, and
&lt;http://www.poms.ac.uk/rdf/entity/Role/7&gt; is the <i>Beneficiary</i> role. We will need both these URI's in subsequent example queries coming up.</p>
<p>In addition, later in the sequence of queries coming up below we will need to find out which Transaction Type (<code>vocab:TransactionType</code>) represents a <i>Gift</i>. Since. like <code>vocab:Role</code>, <code>vocab:TransactionType</code> is also an authority list, the same query, with <code>vocab:Role</code> replaced by <code>vocab:TransactionType</code> will display the list of all transaction types, and we can establish which one is a type of Gift. You can run this by editing the query in the form above in this way, and running the new query.

<h3 id="second">Women as grantors and beneficiaries in legal charters</h3>
<p>In this section we shall gradually develop a query to allow us to see where in PoMS materials there are charters that have women both as grantors and as beneficiaries. We do this by building up gradually more complex queries until we have the one that does the job for us.</p>
<h4>Query selecting all women</h4>
<p>Let us begin by using a query that shows us all women that are registered in PoMS.  Here it is:</p>
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="12" cols="80" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
select ?aperson ?herName ?id ?flStart ?flEnd
where {
 ?aperson a vocab:HistoricalFemale;
   vocab:hasID ?id;
   vocab:hasPersonDisplayName ?herName;
   vocab:hasFloruitStartYr ?flStart;
   vocab:hasFloruitEndYr ?flEnd.
}
order by ?herName
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>
<p>The <i>select</i> clause tells SPARQL to generate a 5 column display, showing in each row of results the values that the
variables <code>aperson</code>, <code>herName</code>, etc. have. To sort out what the variables actually mean requires us to examine how they are selected from the data via the query's somewhat more complex multi-line <i>where</i> clause. It asks the SPARQL processor to select all persons that are a <code>vocab:HistoricaFemale</code>, and for each one to set the values of the other variables it is to display with statements associated with this person, and that have predicates as shown: <code>vocab:hasID</code>, <code>vocab:hasPersonDisplayName</code>, etc. Therefore, putting the <i>where</i> clause together with the <i>select</i> clause shows us that the 5 columns will be, for each woman, her URI identifier, her display name, her ID number, and the floruit start and end year associated with her. Finally, the one-line <i>order by</i> clause at the very end of the query asks the processor to sort the results by the woman's name. Finally note the first line of the query. It is a <i>prefix</i> element which links the predicate "vocab:" to the URI for the PoMS ontology.  Thus, all items in the query referred to with the <code>vocab:</code> prefix are items defined in the ontology.</p>

<h4>Query selecting woman who are grantors only</h4>
<p>The query above selects all women in the PoMS data, but does not filter this selection to show only those who were grantors in one or more of the legal charters. How do we exploit the structure of the data to filter what is chosen in this way? PoMS is a factoid prosopography, and so uses the concepts associated with factoids to organise its materials. Reading the description of the PoMS ontology <a href="ontology.html" target="_blank">here</a>, we find that the <a href="ontology.html#references" target="_blank">vocab:Reference</a> provides the information we need. As it says in the ontology description of the <code>vocab:PersonReference</code>, the particular <code>vocab:Role</code> for a person in a particular factoid is specified through a property:</p>
<quote>
there is a property <i>:hasRole</i> for <i>:PersonReference</i>
that asserts the particular role for this person in this factoid, by pointing
at one of the roles in the authority list <i>:Role</i>.
</quote>
<p>You can see this in the portion of the PoMS ontology's class relationship diagram, particularly the portion about references:</p>
<p><img border=0 width=602 src="images/reference.png"></p>
<p>... and can see there the property of the <code>vocab:PersonReference</code> kind of <code>vocab:Reference</code> called "vocab:hasRole" which associates a particular role to each person reference.</p>
<p>Having now seen better how the roles are managed in the structure of PoMS, we are ready to consider the next query, which uses the <code>vocab:Role</code> in a <code>vocab:PersonReference</code> and restricts it to the role of grantor (you might recall that the first query example, above, has shown us that the Grantor role has URI <a href="/rdf/entity/Role/5" target="_blank">&lt;http://www.poms.ac.uk/rdf/entity/Role/5&gt;</a>):</p>
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="16" cols="80" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
select ?grantor ?grantorURI ?factoid
where {
 ?grantorURI a vocab:HistoricalFemale;
   vocab:hasPersonDisplayName ?grantor.
 ?areference vocab:referencesPerson ?grantorURI;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/5&gt;;
    vocab:hasFactoid ?factoid.
}
order by ?grantor
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>
<p>The <i>select</i> clause here asks the processor to display only three variables, and after we have examined the <i>where</i> clause that follows it we can see that these are the woman grantor's name, her URI, and the URI of the factoid (presumably in a <code>vocab:TransactionFactoid</code>) that has her acting as grantor.  The first two lines of the <i>where</i> clause makes sure that only women are selected, and for each one selects her display name which will be used for display purposes in the result.  The next three lines selects the references that are connected to this woman, selects only those that have a role of Grantor, and selects the URI of the factoid which has this reference in it.</p>
<p>The resulting display shows most of the women appearing in more than one row. This is because they are acting as grantor in more than one transaction factoid.  If we had wanted a simple list of women who acted as grantors -- one row for each -- we get this by changing the query: removing ?factoid from the select cause, and adding the word "distinct" after select, like this:</p>
<pre>
select distinct ?grantor ?grantorURI
</pre>
<p>You can try this by changing the select clause in this way, and running the resultant query again.</p>

<h4>What kinds of transactions have women grantors?</h4>
<p>What kind of transactions had women as grantors? The transaction factoid has a rich and complex structure, with much information potentially attached to each transaction in the PoMS data. One can see much of this complexity by looking at the factoid part of the relationship diagram:</p>
<p><img border=0 width=602 src="images/factoid.png"></p>
<p>Here you can see the <code>vocab:TransactionType</code> authority list, where each individual transaction type as defined by the PoMS team is assigned an instance.  As the figure shows, the property <code>vocab:isTransactionType</code> links the transaction factoid to a particular type.</p>
<p>The next query includes, for each factoid, the <i>kind</i> of transaction assigned to it:</p>
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="18" cols="80" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
select ?grantor ?grantorURI ?factoid ?ttype ?typename
where {
 ?grantorURI a vocab:HistoricalFemale;
   vocab:hasID ?id;
   vocab:hasPersonDisplayName ?grantor.
 ?areference vocab:referencesPerson ?grantorURI;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/5&gt;;
    vocab:hasFactoid ?factoid.
  ?factoid a vocab:TransactionFactoid;
    vocab:isTransactionType ?ttype.
  ?ttype vocab:hasName ?typename.
}
order by ?grantor
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>
<p>The last three lines of the <i>where</i> clause have been added to gather the transaction type information, and the resulting selected material has been added to the select statement.  The third last line of the select clause asserts that the factoids selected by the part of the query above this has to be a <code>vocab:TransactionFactoid</code>.  Each transaction factoid will have a transaction type associated with it, and the URI for each factoid type is specified through the transaction factoid's <code>vocab:isTransactionType</code> property.  The last line of this query takes advantage of the fact that   <code>vocab:TransactionType</code> instances are pointed to by transaction factoids via the property <code>vocab:isTransactionType</code>. <code>vocab:TransactionsType</code> is an authority lists, and so have a name provided through the <code>vocab:hasName</code> property.</p>
<p>A look at the resultant display shows that the great majority of transactions involving women as grantors are identified as gifts by PoMS, but with a range of other types including sales, quitclaims, etc. Change the order by clause to <code>order by ?typename</code> to group the types together.</p>

<h4>All gift transactions where women are grantors</h4>
<p>We will focus here on gift transactions.  In the following query we add further parts to the where clause to find out who are the beneficiaries. This is done by adding material to the query that selects a <code>vocab:PersonReference</code> of type "Beneficiary" (Role 7), and then establishing the name of the person.  Here is the relevant fragment:</p>
<pre>
  ?breference vocab:hasFactoid ?factoid;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/7&gt;;
    vocab:referencesPerson ?beneURI.
  ?beneURI vocab:hasPersonDisplayName ?beneficiary.
</pre>
<p>... and here is the full query:
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="20" cols="100" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
select ?grantor ?grantorURI ?factoid ?beneficiary ?beneURI 
where {
 ?grantorURI a vocab:HistoricalFemale;
   vocab:hasID ?id;
   vocab:hasPersonDisplayName ?grantor.
 ?areference vocab:referencesPerson ?grantorURI;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/5&gt;;
    vocab:hasFactoid ?factoid.
  ?factoid a vocab:TransactionFactoid;
    vocab:isTransactionType &lt;http://www.poms.ac.uk/rdf/entity/TransactionType/2&gt;.
  ?breference vocab:hasFactoid ?factoid;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/7&gt;;
    vocab:referencesPerson ?beneURI.
  ?beneURI vocab:hasPersonDisplayName ?beneficiary.
}
order by ?grantor
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>

<h4>Selecting grant transactions where women are grantors and women are beneficiaries (i)</h4>
<p>We are getting close to aim is finding transactions where women are both grantors and beneficiaries. We must simply add a restriction to the query above so that the beneficiary (referenced in the query by variable ?beneURI) can only be a women.  Here is the query that does this:</p>
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="20" cols="100" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#>
select ?grantor ?grantorURI ?factoid ?ttype ?typename ?beneficiary ?beneURI
where {
 ?grantorURI a vocab:HistoricalFemale;
   vocab:hasID ?id;
   vocab:hasPersonDisplayName ?grantor.
 ?areference vocab:referencesPerson ?grantorURI;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/5>;
    vocab:hasFactoid ?factoid.
  ?factoid a vocab:TransactionFactoid;
    vocab:isTransactionType ?ttype.
  ?ttype vocab:hasName ?typename.
  ?breference vocab:hasFactoid ?factoid;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/7&gt;;
    vocab:referencesPerson ?beneURI.
  ?beneURI a vocab:HistoricalFemale;
    vocab:hasPersonDisplayName ?beneficiary.
}
order by ?grantor
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>
<p>The 2nd last line of the where clause does this by asserting that <code>?beneURI</code> must be a <code>vocab:HistorialFemale</code>.</p>
<p>When the query is run you will notice that the PoMS team have decided to include the Blessed Virgin Mary as a women, and some characters evidently make reference to her as the beneficiary! This is, of course, perhaps understandable, but is not what we might want for our explorations here.  In the next step, we will explicitly exclude her from our considerations.</p>
<h4>Selecting grant transactions where women are grantors and women are beneficiaries (ii)</h4>
<p>We'd like to exclude the Blessed Virgin Mary as one of the beneficiaries for our query.  The display generated by the previous query shows that the BVM has the URI <code>&lt;http://www.poms.ac.uk/rdf/entity/Person/710&gt;</code>. Now that we know  the URI for the BVM, we can explicitly exclude her as beneficiary by using a SPARQL filter mechanism called "MINUS" including a pattern that explicitly references her URI:</p>
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="20" cols="100" wrap="soft">
PREFIX vocab: <http://www.poms.ac.uk/rdf/ontology#>
select ?grantor ?grantorURI ?factoid ?ttype ?typename ?beneficiary ?beneURI
where {
 ?grantorURI a vocab:HistoricalFemale;
   vocab:hasID ?id;
   vocab:hasPersonDisplayName ?grantor.
 ?areference vocab:referencesPerson ?grantorURI;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/5&gt;;
    vocab:hasFactoid ?factoid.
  ?factoid a vocab:TransactionFactoid;
    vocab:isTransactionType ?ttype.
  ?ttype vocab:hasName ?typename.
  ?breference vocab:hasFactoid ?factoid;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/7&gt;;
    vocab:referencesPerson ?beneURI.
  ?beneURI a vocab:HistoricalFemale;
     vocab:hasPersonDisplayName ?beneficiary.
  MINUS{?breference vocab:referencesPerson &lt;http://www.poms.ac.uk/rdf/entity/Person/710&gt;}
}
order by ?grantor
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>
<p>You can see the MINUS filter near the end of the query. Here, it tells the SPARQL processor to exclude any <code>?breference</code> (URI for women beneficiaries) which has the property <code>vocab:referencesPerson</code> pointing to the URI for the BVM.</p>
<h4>Where are the properties exchanged between women?</h4>
<p>A further expansion of the query allows us to retrieve information about where in Scotland the properties involved in these transactions between women are located. To do this we make use of the fact that Transaction Factoids are connected through <code>vocab:PossessionReference</code> to one or more Possessions (<code>vocab:Possession</code>) which for land possessions are connected to places (<code>vocab:Place</code>).  You can see <code>vocab:Place</code> in PoMS's relationship diagram.  Here is a part of it that focuses on Place:</p>
<p><img border=0 width=602 src="images/place.png"></p>
<p>... and here is the query that fetches the relevant place data via the vocab:PossessionLand</p>
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="20" cols="100" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
select ?grantor ?grantorURI ?factoid ?beneficiary ?beneURI ?possName ?placeName
where {
 ?grantorURI a vocab:HistoricalFemale;
   vocab:hasID ?id;
   vocab:hasPersonDisplayName ?grantor.
 ?areference vocab:referencesPerson ?grantorURI;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/5&gt;;
    vocab:hasFactoid ?factoid.
  ?factoid a vocab:TransactionFactoid.
  ?breference vocab:hasFactoid ?factoid;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/7&gt;;
    vocab:referencesPerson ?beneURI.
  ?beneURI a vocab:HistoricalFemale;
     vocab:hasPersonDisplayName ?beneficiary.
  MINUS{?breference vocab:referencesPerson &lt;http://www.poms.ac.uk/rdf/entity/Person/710&gt;}
  ?possref a vocab:PossessionReference;
      vocab:hasFactoid ?factoid;
      vocab:referencesPossession ?possession.
  ?possession a vocab:PossessionLand;
      vocab:hasName ?possName;
      vocab:hasPlace ?possPlace.
  ?possPlace a vocab:Place;
      vocab:hasName ?placeName.
}
order by ?grantor
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>

<h3 id="geographic">Using vocab:Place's Geographic Data in SPARQL</h3>
<p>In PoMS the instances of <code>vocab:Place</code> can have three properties that contain geographic data. It is important to understand that not all vocab:Place instances have this geographic data: in many cases the location of the named place was unknown to the PoMS team.  Also, the team often did not provide geographic position data for places outside of Scotland.</p>
<p>When it is provided, this data takes the form of a geographic point that represent the location of the place in Scotland.  In fact, of course, all places are more properly represented as geographic <i>areas</i> rather than <i>points</i>, but establishing boundaries for all the places would have been both much more time consuming, and in some cases more problematic, than providing a single point.</p>
<p>The three properties are:</p>
<ul>
<li><code>vocab:hasGeographicLatitude</code>: A numeric value (double floating point) that represents the geographic latitude of the point associated with the place. e.g. 5.56E1</li>
<li><code>vocab:hasGeographicLongitude</code>: A numeric value (double floating point) that represents the geographic longitude of the point associated with the place. e.g. -3.055E0</li>
<li><code>vocab:hasGeoData</code>: the longitude and latitude of the point, given in wktLiteral notation. e.g. 	
<code>"POINT(-3.055 55.6)"^^geo:wktLiteral</code></li>
</ul>
<p>By including data from the Latitude and Longitude properties in SPARQL queries, the Latitude and Longitude values can provide values to software (such as, say, mapping software) that can make use of these values.  For example, the demonstration application <i>mapapp</i>, available from this server <a href="../mapapp/index.html" target="_blank">here</a>, is a small Python script that takes latitude and longitude values from the results of a SPARQL query and projects them onto an interactive map of Scotland expressed as a simple HTML page. Indeed, a minor change to the query shown above that generates places associated with property exchanges between women is the one used in the demo application to provide the data for the map:
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="20" cols="100" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
select ?grantor ?grantorURI ?factoid ?beneficiary ?beneURI ?possName ?label ?lat ?long
where {
 ?grantorURI a vocab:HistoricalFemale;
   vocab:hasID ?id;
   vocab:hasPersonDisplayName ?grantor.
 ?areference vocab:referencesPerson ?grantorURI;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/5&gt;;
    vocab:hasFactoid ?factoid.
  ?factoid a vocab:TransactionFactoid.
  ?breference vocab:hasFactoid ?factoid;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/7&gt;;
    vocab:referencesPerson ?beneURI.
  ?beneURI a vocab:HistoricalFemale;
     vocab:hasPersonDisplayName ?beneficiary.
  MINUS{?breference vocab:referencesPerson &lt;http://www.poms.ac.uk/rdf/entity/Person/710&gt;}
  ?possref a vocab:PossessionReference;
      vocab:hasFactoid ?factoid;
      vocab:referencesPossession ?possession.
  ?possession a vocab:PossessionLand;
      vocab:hasName ?possName;
      vocab:hasPlace ?possPlace.
  ?possPlace a vocab:Place;
      vocab:hasName ?label;
      vocab:hasGeographicLatitude ?lat;
      vocab:hasGeographicLongitude ?long.
}
order by ?grantor
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>
<p>One can see the html page that this python script generates from the data extracted through this query <a href="../mapapp/mapapp1.html" target="_blank">here</a>.</p>

<h4>Places involved in charters in Gaelic</h4>
<p>The following query collects data about the few charters that PoMS researchers have from the medieval period that are written in Gaelic.  The language used in each charter is associated with it associated <code>vocab:Source</code> instance. By building a query which then locates the factoids associated with these Gaelic charters, and then locating from them the properties and places involve one can see where geographically the properties were that were referenced in these Gaelic language charters:</p>
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="20" cols="100" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
select ?source ?factoid ?possession ?place ?label ?lat ?long
where {
  ?source vocab:hasLanguage &lt;http://www.poms.ac.uk/rdf/entity/Language/Gaelic&gt;.
  ?factoid vocab:hasSource ?source;
     a vocab:TransactionFactoid.
  ?possref vocab:hasFactoid ?factoid;
     vocab:referencesPossession ?possession.
  ?possession a vocab:PossessionLand;
     vocab:hasPlace ?place.
  ?place vocab:hasName ?label;
      vocab:hasGeographicLatitude ?lat;
      vocab:hasGeographicLongitude ?long.
}
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>
<p>This query is structured so that it would replace the query already in mapapp. Thus the same script could then be run to produce a map showing where these properties are located. Once this query is established to be working, one can add a bit more to the process to select additional data about the factoid, source and property that will then enrich the popup text that the map will display.</p>
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="20" cols="100" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
select ?source ?sourceName ?factoid ?factName ?possession ?possName ?place ?label ?lat ?long
where {
  ?source vocab:hasLanguage &lt;http://www.poms.ac.uk/rdf/entity/Language/Gaelic&gt;;
     rdfs:label ?sourceName.
  ?factoid vocab:hasSource ?source;
     rdfs:label ?factName;
     a vocab:TransactionFactoid.
  ?possref vocab:hasFactoid ?factoid;
     vocab:referencesPossession ?possession.
  ?possession a vocab:PossessionLand;
     vocab:hasName ?possName;
     vocab:hasPlace ?place.
  ?place vocab:hasName ?label;
      vocab:hasGeographicLatitude ?lat;
      vocab:hasGeographicLongitude ?long.
}
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>

<h3 id="geosparql">PoMS RDF and GeoSPARQL</h3>
<p>RDF4J's SPARQL processor incorporates code that implements large parts of the <i>GeoSPARQL</i> specification which allows queries to be created that make use of geographic concepts such as geographic containment and geographic distance. Thus, GeoSPARQL queries can be given to PoMS's RDF server as well. (About GeoSPARQL in <i>rdf4j</i> see pages at <a href="https://github.com/eclipse/rdf4j-doc/blob/master/site/content/documentation/programming/geosparql/index.md" target="_blank">GitHub</a> and <a href="https://rdf4j.eclipse.org/documentation/programming/geosparql/">rdfj4</a> itself).</p>
<p>It is outside the scope of this document to present the GeoSPARQL features in detail. However, a few SPARQL queries that make use of them will hopefully be helpful to demonstrate how this might be useful.</p>
<h4>A simple GeoSPARQL example</h4>
<p>GeoSPARQL can make best use of vocab:Place's vocab:hasGeoData property, which provides the point coordinate data in the format that GeoSPARQL functions understand: wktLiteral notation. This simplest of GeoSPARQL-powered queries uses the function geof:distance to calculate the distance in kilometers between the two places specified explicitly in the query:</p>
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="10" cols="100" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
PREFIX uom: &lt;http://www.opengis.net/def/uom/OGC/1.0/&gt;
PREFIX geof: &lt;http://www.opengis.net/def/function/geosparql/&gt;
SELECT ?coord1 ?coord2 ?dist
WHERE {
   &lt;http://www.poms.ac.uk/rdf/entity/Place/10&gt; vocab:hasGeoData ?coord1.
   &lt;http://www.poms.ac.uk/rdf/entity/Place/100&gt; vocab:hasGeoData ?coord2.
  BIND((geof:distance(?coord1, ?coord2, uom:metre)/1000) as ?dist) .
}
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>

<h4>Places in PoMS near to Dundee</h4>
<p>The following query produces a list, ordered by distance, of places in PoMS that are close to what is now the modern Scottish city of Dundee (co-ordinates: lat 56.462, long -2.9707). Note the use of <code>geof:buffer</code> which creates a circular shape centered on Dundee's coordinates of 15 kilometers in size. This is given as the area for <code>geof:sfWithin</code> to use to check whether each place with a value for vocab:hasGeoData is inside this circular area or not.
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="12" cols="100" wrap="soft">
PREFIX uom: &lt;http://www.opengis.net/def/uom/OGC/1.0/&gt;
PREFIX geof: &lt;http://www.opengis.net/def/function/geosparql/&gt;
PREFIX geo: &lt;http://www.opengis.net/ont/geosparql#&gt;
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
select ?what ?name ?dist ?itemgeom
where {
  ?what vocab:hasName ?name;
  vocab:hasGeoData ?itemgeom
  FILTER(geof:sfWithin(?itemgeom, geof:buffer("POINT(-2.9707 56.462)"^^geo:wktLiteral, 15000.0, uom:metre))).
  BIND((geof:distance("POINT(-2.9707 56.462)"^^geo:wktLiteral, ?itemgeom, uom:metre)/1000) as ?dist) .
} order by ?dist
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>
<h4>Places in PoMS near a place in PoMS</h4>
<p>A minor extension to the query above allows one to use any place with a point coordinate in PoMS as the centre for the "near to" query. &lt;http://www.poms.ac.uk/rdf/entity/Place/2459&gt; is Glasgow Cathedral.
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="12" cols="100" wrap="soft">
PREFIX uom: &lt;http://www.opengis.net/def/uom/OGC/1.0/&gt;
PREFIX geof: &lt;http://www.opengis.net/def/function/geosparql/&gt;
PREFIX geo: &lt;http://www.opengis.net/ont/geosparql#&gt;
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
select ?what ?name ?dist
where {
  &lt;http://www.poms.ac.uk/rdf/entity/Place/2459&gt; vocab:hasGeoData ?centre.
  ?what vocab:hasName ?name;
  vocab:hasGeoData ?itemgeom
  FILTER(geof:sfWithin(?itemgeom, geof:buffer(?centre, 15000.0, uom:metre))).
  BIND((geof:distance(?centre, ?itemgeom, uom:metre)/1000) as ?dist) .
} order by ?dist
</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>

<h4>Properties Granted to Glasgow Cathedral with distances</h4>
<p>GeoSPARQL operations can be integrated into more general queries. In this example most of the query establishes places that have been granted to Glasgow Cathedral (&lt;http://www.poms.ac.uk/rdf/entity/Person/186&gt;, Place: &lt;http://www.poms.ac.uk/rdf/entity/Place/2459&gt;), but uses GeoSPARQL's geof:distance function to establish distance in kilometers from the cathedral itself for each of the land possessions granted to it (and that have geographic information available, of course).</p>
<form action="/rdf/repositories/poms/query" target="_blank">
<code><textarea id="query" name="query" rows="20" cols="100" wrap="soft">
PREFIX vocab: &lt;http://www.poms.ac.uk/rdf/ontology#&gt;
PREFIX geof: &lt;http://www.opengis.net/def/function/geosparql/&gt;
PREFIX uom: &lt;http://www.opengis.net/def/uom/OGC/1.0/&gt;
select ?grantor ?grantorURI ?factoid ?flabel ?place ?placeName ?dist
where {
 &lt;http://www.poms.ac.uk/rdf/entity/Place/2459&gt; vocab:hasGeoData ?cathedral.
 ?grantorURI a vocab:Person;
   vocab:hasID ?id;
   vocab:hasPersonDisplayName ?grantor.
 ?breference vocab:referencesPerson &lt;http://www.poms.ac.uk/rdf/entity/Person/186&gt;;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/7&gt;;
    vocab:hasFactoid ?factoid.
 ?greference vocab:referencesPerson ?grantorURI;
    vocab:hasRole &lt;http://www.poms.ac.uk/rdf/entity/Role/5&gt;;
    vocab:hasFactoid ?factoid.
 ?factoid rdfs:label ?flabel.
 ?ref vocab:hasFactoid ?factoid;
    vocab:referencesPossession ?possURI.
 ?possURI vocab:hasPlace ?place.
 ?place vocab:hasGeoData ?point;
    vocab:hasName ?placeName;
    vocab:hasGeoData ?placeGeo.
  BIND((geof:distance(?cathedral, ?placeGeo, uom:metre)/1000) as ?dist) .
}
order by ?dist</textarea></code>
<input type="hidden" name="ref" value="text"/>
<input type="hidden" name="queryLn" value="SPARQL"/>
<input type="hidden" name="limit_query" value="0"/>
<br />
<input id="exec" type="submit" value="Execute"/>
</form>
<p>The places are ordered by distance so that one can readily see what places have been granted to the cathedral that are some distance off.</p>
    </div>
  </div>

  <footer id="myFooter">
    <div class="w3-container w3-theme-l2 w3-padding-32">
      <p><b>Copyright 2019 John Bradley, King's College London</b></p>
	  <p><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /></a> This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.
    </div>

    <div class="w3-container w3-theme-l1">
      <p>These documentation pages are powered by <a href="https://www.w3schools.com/w3css/default.asp" target="_blank">w3.css</a></p>
    </div>
  </footer>

<!-- END MAIN -->
</div>

<script>
// Get the Sidebar
var mySidebar = document.getElementById("mySidebar");
buildSidebar();

// Get the DIV with overlay effect
var overlayBg = document.getElementById("myOverlay");

// Toggle between showing and hiding the sidebar, and add overlay effect
function w3_open() {
    if (mySidebar.style.display === 'block') {
        mySidebar.style.display = 'none';
        overlayBg.style.display = "none";
    } else {
        mySidebar.style.display = 'block';
        overlayBg.style.display = "block";
    }
}

// Close the sidebar with the close button
function w3_close() {
    mySidebar.style.display = "none";
    overlayBg.style.display = "none";
}

function dummy(){
   window.alert("dummy");
}
</script>


</body></html>